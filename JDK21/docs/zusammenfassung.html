<!DOCTYPE html>
<html>
<head>
<title>zusammenfassung.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>
<link rel="stylesheet" href="file:///c%3A/Users/K_Schenker/Desktop/dev/settings/markdown-style.css" type="text/css">
<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="java-quelltext-%C3%BCbersetzen-und-ausf%C3%BChren">Java-Quelltext übersetzen und ausführen</h1>
<pre class="hljs"><code><div><span class="hljs-comment"># Projektverzeichnis erstellen.</span>
mkdir projekt
<span class="hljs-comment"># In Projektverzeichnis wechseln.</span>
cd projekt
<span class="hljs-comment"># Quelltextdatei erzeugen und editieren. (SPEICHERN!)</span>
notepad MyClass.java
<span class="hljs-comment"># Quelltextdatei mit Java Compiler übersetzen.</span>
<span class="hljs-comment"># Erfolgt keine Ausgabe, war die Übersetzung erfolgreich.</span>
javac MyClass.java
<span class="hljs-comment"># Mit dem Java Launcher eine Klasse starten (deren main-Methode).</span>
java MyClass
</div></code></pre>
<p>Hinweis: Kleinere Programme können mit mit dem Java Launcher direkt übersetzt und sofort danach ausgeführt werden. Allerdings wird die class Datei nicht gespeichert. Beispiel:</p>
<pre class="hljs"><code><div><span class="hljs-comment"># Launcher erkennt, dass es sich um eine Quelltextdatei handelt.</span>
<span class="hljs-comment"># Er übersetzt zuerst die Datei und führt sie gleich danach aus.</span>
java MyApp.java
</div></code></pre>
<h1 id="wozu-brauchen-wir-datentypen">Wozu brauchen wir Datentypen?</h1>
<ul>
<li>Ein Datentyp definiert, wie ein Bitmuster im Speicher zu interpretieren ist. Beispiel: Was bedeutet die Bitfolge <code>011001</code>?</li>
<li>Ein Datentyp legt fest, wie viel Speicher für eine Variable zu reservieren ist. Beispiel: Eine Variable vom Typ <code>int</code> belegt 32 Bits (also 4 Bytes) im Speicher.</li>
<li>Ein Datentyp definiert den Wertebereich für eine Variable. Beispiel: Der Datentyp <code>byte</code> lässt nur Werte im Bereich <code>-128</code> bis <code>+127</code> zu.</li>
<li>Ein Datentyp legt fest, welche Operationen mit einer Variablen zulässig sind. Beispiel: Einen <code>int</code> kann man multiplizieren, aber einen <code>String</code> hingegen nicht.</li>
<li>Ein Datentyp liefert dem Compiler zusätzliche Informationen, damit er die typkonforme Verwendung der Variablen prüfen kann.</li>
<li>Datentypen legen die Intention für Variablen fest und fördern damit die Verständlichkeit des Quelltextes.</li>
</ul>
<p>In Java gibt es zwei Kategorien von Datentypen:</p>
<ul>
<li>Primitive Datentypen</li>
<li>Referenzdatentypen</li>
</ul>
<p>Hinweis: Für jeden primitiven Datentyp existiert in Java ein korrespondierender Referenzdatentyp - sogenannte Wrapper-Klassen. Beispiel: <code>byte</code> und <code>Byte</code>, <code>char</code> und <code>Character</code>, <code>double</code> und <code>Double</code>.</p>
<p>Um den Wertebereich eines primitiven Datentyps zu ermitteln, verwende dessen zugehörige Wrapper-Klasse. Beispiel:</p>
<pre class="hljs"><code><div>Byte.MIN_VALUE
Byte.MAX_VALUE
Integer.MAX_VALUE
Integer.MIN_VALUE
</div></code></pre>
<h1 id="rundungsfehler-bei-datentyp-double-und-float">Rundungsfehler bei Datentyp <code>double</code> und <code>float</code></h1>
<p>Mit den Datentypen <code>double</code> und <code>float</code> können wir Zahlen mit Nachkommastellen abspeichern. Hier kann es jedoch zu Rundungsfehlern kommen. Für <code>double</code> gilt: Ungefähr 15 signifikante Ziffern können exakt dargestellt werden. Bei Datentyp <code>float</code> sind es hingegen nur etwa 7.</p>
<p>Die <em>betragsmäßig</em> größte Zahl ist bei <code>double</code> etwa 1.8E308 und die betragsmäßig kleinste Zahl ist 4.9E-328. (E-328 bedeutet &quot;10 hoch -328&quot;).</p>
<p>Achtung: Manche Dezimalzahlen, z.B. 0.1, sind im Binärsystem nicht exakt darstellbar. Diese können nur gerundet abgespeichert werden.</p>
<h1 id="faustregeln-bei-typkonvertierungen">Faustregeln bei Typkonvertierungen</h1>
<p>Merke:</p>
<ul>
<li>Ganze Zahlen haben den Datentyp <code>int</code>.</li>
<li>Zahlen mit Nachkommastellen bzw. Dezimaltrenner (<code>.</code>) haben den Datentyp <code>double</code>.</li>
<li>Verwendet man die wissenschaftliche Notation (z.B. <code>2e-3</code>) so hat dieser Wert den Datentyp <code>double</code>.</li>
<li>Um eine Gleitkommazahl als Float anzugeben, verwende den Suffix <code>f</code>. Beispiel: <code>2.5f</code>.</li>
</ul>
<p>Regeln:</p>
<ul>
<li>Wenn man zwei <code>int</code> Werte miteinander verrechnet, entsteht wieder ein Ergebnis vom Typ <code>int</code>. Nachkommastellen werden abgeschnitten.</li>
<li>Verrechnet man zwei Werte miteinander, wobei mindestens ein Wert ein <code>double</code> ist, dann ist das Gesamtergebnis vom Typ <code>double</code>.</li>
<li>Verrechnet man zwei <code>byte</code> Werte miteinander, ist das Ergebnis vom Typ <code>int</code>.</li>
<li>Verrechnet man zwei <code>short</code> Werte miteinander, ist das Ergebnis vom Typ <code>int</code>.</li>
<li>Verrechnet man zwei <code>float</code> Werte miteinander, ist das Ergebnis vom Typ <code>float</code>.</li>
</ul>
<h1 id="zahlen-angeben-in-verschiedenen-zahlensystemen">Zahlen angeben in verschiedenen Zahlensystemen</h1>
<p>In Java können Zahlen im Binär-, Oktal-, Dezimal- und Hexadezimalsystem angegeben werden.</p>
<p>Binäre Zahlen beginnen mit Präfix <code>0b</code>, oktale Zahlen beginnen mit Präfix <code>0</code> und hexadezimale Zahlen beginnen mit Präfix <code>0x</code>. Ohne Präfix werden Zahlen als Dezimalzahlen interpretiert.</p>
<h1 id="was-war-noch-mal-der-unterschied-zwischen-instanzmethoden-und-statischen-methoden">Was war noch mal der Unterschied zwischen Instanzmethoden und statischen Methoden?</h1>
<p>Eine Instanz ist ein Objekt einer Klasse. Jede Instanz hat eine Identität, einen Zustand und ein Verhalten.</p>
<p>Instanzmethoden sind Methoden, die auf einem Objekt aufgerufen werden müssen. Diese Methoden haben Zugriff auf die Instanzzustand.</p>
<p>Statische Methoden sind Methoden, die direkt auf der Klasse aufgerufen werden. Sie benötigen kein Objekt, um ihre Aufgabe durchzuführen. Selbst wenn man auf einem Objekt eine statische Methode aufruft, so hat sie dennoch keinen Zugriff auf den Objektzustand. Beispiel: Die Methoden <code>sin</code>, <code>cos</code>, <code>pow</code> der Klasse <code>Math</code>. Statische Methoden werden i.d.R. für Algorithmen verwendet oder einfach nur als Hilfsmethoden. Weitere Beispiele: Die Methoden <code>valueOf</code> und <code>format</code> der Klasse <code>String</code>.</p>
<p>In Java werden statische Methoden häufig auch als Factory-Methoden verwendet. Eine Factory-Methode hat die Aufgabe, Objekte einer Klasse zu erzeugen.</p>
<h1 id="wichtige-string-methoden">Wichtige String-Methoden</h1>
<p>Merke: Ein String-Objekt ist unveränderlich. Jeder Methodenaufruf auf einem String-Objekt liefert ein neues String-Objekt als Ergebnis!</p>
<p>Achtung: Bei den meisten Methoden wird die Groß- und Kleinschreibung berücksichtigt!</p>
<p>Merke: Wenn du Zeichenketten vergleichst, verwende statt <code>==</code> die <code>equals</code> bzw. die <code>equalsIgnoreCase</code> Methode! Der Vergleichsoperator <code>==</code> prüft, ob zwei Variablen auf <em>dasselbe</em> Objekt verweisen, während <code>equals</code> prüft, ob die beiden Variablen <em>gleiche</em> Werte enthalten.</p>
<pre class="hljs"><code><div>String name = <span class="hljs-string">"alice"</span>;
name.length(); <span class="hljs-comment">// 5</span>
name.charAt(<span class="hljs-number">0</span>); <span class="hljs-comment">// 'a'</span>
name.charAt(name.length() - <span class="hljs-number">1</span>); <span class="hljs-comment">// 'e'</span>
String message = <span class="hljs-string">"The result is: "</span> + <span class="hljs-number">123.5</span>; <span class="hljs-comment">// "The result is 123.5"</span>
String.valueOf(<span class="hljs-keyword">true</span>); <span class="hljs-comment">// "true"</span>
String.valueOf(<span class="hljs-number">456</span>); <span class="hljs-comment">// "456"</span>
name = <span class="hljs-string">"Alice Wonderland"</span>;
name.substring(<span class="hljs-number">6</span>); <span class="hljs-comment">// "Wonderland"</span>
name.substring(<span class="hljs-number">6</span>, <span class="hljs-number">9</span>); <span class="hljs-comment">// "Won"</span>
name.toLowerCase(); <span class="hljs-comment">// "alice wonderland"</span>
name.toUpperCase(); <span class="hljs-comment">// "ALICE WONDERLAND"</span>
<span class="hljs-string">"abc"</span>.repeat(<span class="hljs-number">3</span>); <span class="hljs-comment">// "abcabcabc"</span>
<span class="hljs-string">" some text  "</span>.trim() <span class="hljs-comment">// "some text"</span>
<span class="hljs-string">"His name is \"Bob\"!"</span>; <span class="hljs-comment">// His name is "Bob"!</span>
<span class="hljs-string">"2024-03-02"</span>.split(<span class="hljs-string">"-"</span>); <span class="hljs-comment">// String[3] { "2024", "03", "02" }</span>
<span class="hljs-string">"2024.03.02"</span>.split(<span class="hljs-string">"\\."</span>); <span class="hljs-comment">// String[3] { "2024", "03", "02" }</span>
String.join(<span class="hljs-string">"-"</span>, <span class="hljs-string">"2024"</span>, <span class="hljs-string">"03"</span>, <span class="hljs-string">"02"</span>); <span class="hljs-comment">// "2024-03-02"</span>
<span class="hljs-string">"Alice Bob Charlie"</span>.replace(<span class="hljs-string">" "</span>, <span class="hljs-string">"-"</span>); <span class="hljs-comment">// "Alice-Bob-Charlie"</span>
<span class="hljs-string">"Alice Bob Charlie"</span>.replace(<span class="hljs-string">" "</span>, <span class="hljs-string">""</span>); <span class="hljs-comment">// "AliceBobCharlie"</span>
<span class="hljs-string">"Alice"</span>.startsWith(<span class="hljs-string">"Al"</span>); <span class="hljs-comment">// true</span>
<span class="hljs-string">"Alice"</span>.startsWith(<span class="hljs-string">"al"</span>); <span class="hljs-comment">// false</span>
<span class="hljs-string">"Alice"</span>.endsWith(<span class="hljs-string">"ce"</span>); <span class="hljs-comment">// true</span>
<span class="hljs-string">"Alice"</span>.endsWith(<span class="hljs-string">"e"</span>); <span class="hljs-comment">// true</span>
<span class="hljs-string">"Alice"</span>.endsWith(<span class="hljs-string">""</span>); <span class="hljs-comment">// true</span>
<span class="hljs-string">"Alice"</span>.indexOf(<span class="hljs-string">"ic"</span>); <span class="hljs-comment">// 2</span>
<span class="hljs-string">"Anna"</span>.indexOf(<span class="hljs-string">"n"</span>); <span class="hljs-comment">// 1</span>
<span class="hljs-string">"Anna"</span>.lastIndexOf(<span class="hljs-string">"n"</span>); <span class="hljs-comment">// 2</span>
<span class="hljs-comment">// Ergebnis der folgenden Anweisung: "3,00 + 7,000 ergibt A"</span>
<span class="hljs-string">"%.2f + %.3f ergibt %X"</span>.formatted(<span class="hljs-number">3.0</span>, <span class="hljs-number">7.0</span>, <span class="hljs-number">10</span>);
<span class="hljs-string">"ABC"</span>.equals(<span class="hljs-string">"abc"</span>) <span class="hljs-comment">// false</span>
<span class="hljs-string">"ABC"</span>.equalsIgnoreCase(<span class="hljs-string">"abc"</span>); <span class="hljs-comment">// true</span>
<span class="hljs-string">"Alice Wonderland"</span>.contains(<span class="hljs-string">"Won"</span>); <span class="hljs-comment">// true</span>
<span class="hljs-string">"abc"</span>.compareTo(<span class="hljs-string">"abd"</span>); <span class="hljs-comment">// -1, d.h. "abc" &lt; "abd"</span>
<span class="hljs-string">"abd"</span>.compareTo(<span class="hljs-string">"abc"</span>); <span class="hljs-comment">// 1, d.h. "abd" &gt; "abc"</span>
<span class="hljs-string">"abc"</span>.compareTo(<span class="hljs-string">"abc"</span>); <span class="hljs-comment">// 0, d.h. "abc" = "abc"</span>
</div></code></pre>
<h1 id="bearbeitbare-zeichenketten-mit-dem-stringbuilder">Bearbeitbare Zeichenketten mit dem StringBuilder</h1>
<p>Mit der Klasse StringBuilder können wir Zeichenpuffer erstellen und diese Zeichen direkt bearbeiten, ohne jedes Mal einen neuen String zu erzeugen. Das ist wesentlich effizienter und ressourcenschonender.</p>
<p>Merke: Methoden verändern das StringBuilder-Objekt selbst. Um ein String-Builder Objekt in einen String zu konvertieren, rufe Methode <code>toString</code> auf.</p>
<p>Hinweis: Viele Methoden, die in der Klasse String vorhanden sind, gibt es auch im StringBuilder.</p>
<pre class="hljs"><code><div>String lastName = <span class="hljs-string">"Wonderland"</span>;
StringBuilder buffer = <span class="hljs-keyword">new</span> StringBuilder(lastName);
buffer.insert(<span class="hljs-number">0</span>, <span class="hljs-string">"Alice "</span>); <span class="hljs-comment">// "Alice Wonderland"</span>
buffer.setCharAt(<span class="hljs-number">0</span>, <span class="hljs-string">'a'</span>); <span class="hljs-comment">// "alice Wonderland"</span>
buffer.delete(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>); <span class="hljs-comment">// "Wonderland"</span>
buffer.append(<span class="hljs-string">" from Oz"</span>); <span class="hljs-comment">// "Wonderland from Oz"</span>
String newLastName = buffer.toString();
</div></code></pre>
<h1 id="homogene-daten-speichern-mit-arrays">Homogene Daten speichern mit Arrays</h1>
<p>Ein Array ist eine lineare Datenstruktur, die ihre Elemente sequenziell anordnet. Jedes Element hat eine feste Position (Index). Das erste Element hat den Index 0. Die Elemente müssen denselben Datentyp haben.</p>
<p>Merke: Ein Array kann strukturell nicht verändert werden. D.h. Elemente können weder entfernt noch eingefügt werden. Ein Element lässt sich jedoch mit einem neuen Element ersetzen.</p>
<p>Hinweis: Die Kurzschreibweise <code>{ e1, e2, ... }</code> ist nur bei <em>Variablendefinitionen</em> zulässig. Will man der Array-Variablen später ein neues Array-Objekt zuweisen, geht dies nur mit dem Operator <code>new</code>.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100</span>]; <span class="hljs-comment">// int[100] { 0, 0, ..., 0 }</span>
<span class="hljs-keyword">int</span>[] primes = { <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span> };
primes.length; <span class="hljs-comment">// 5</span>
primes[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 2</span>
primes[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 3</span>
primes[<span class="hljs-number">0</span>] = <span class="hljs-number">19</span>; <span class="hljs-comment">// int[5] { 19, 3, 5, 7, 11 }</span>
primes = { <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span> }; <span class="hljs-comment">// Fehler!!!</span>
primes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] { <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span> }; <span class="hljs-comment">// int[4] {...}</span>
</div></code></pre>
<p>Die Hilfsklasse <code>java.util.Arrays</code> bietet zahlreiche Methoden an, um Array-Objekte zu verarbeiten. Beispiele:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span>[] numbers = { <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span> };
Arrays.sort(numbers); <span class="hljs-comment">// int[4] { 1, 2, 6, 7}</span>
Arrays.fill(numbers, <span class="hljs-number">2</span>); <span class="hljs-comment">// int[4] { 2, 2, 2, 2}</span>
<span class="hljs-keyword">int</span>[] someOtherNumbers = { <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span> };
Arrays.equals(numbers, someOtherNumbers); <span class="hljs-comment">// true</span>
someOtherNumbers = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] { <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span> };
Arrays.equals(numbers, someOtherNumbers); <span class="hljs-comment">// false</span>
String[] names = { <span class="hljs-string">"alice"</span>, <span class="hljs-string">"bob"</span>, <span class="hljs-string">"charlie"</span>, <span class="hljs-string">"damian"</span> };
<span class="hljs-comment">// Achtung: binarySearch erwartet, dass die Elemente des Arrays </span>
<span class="hljs-comment">// aufsteigend sortiert sind!</span>
Arrays.binarySearch(names, <span class="hljs-string">"bob"</span>); <span class="hljs-comment">// 1</span>
<span class="hljs-keyword">int</span>[] b1 = { <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span> };
<span class="hljs-keyword">int</span>[] b2 = { <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> };
Arrays.compare(b1, b2); <span class="hljs-comment">// -1, d.h. b1 &lt; b2</span>
Arrays.compare(b2, b1); <span class="hljs-comment">// 1, d.h. b2 &gt; b1</span>
Arrays.compare(b2, b2); <span class="hljs-comment">// 0, d.h. b2 gleich b2</span>
<span class="hljs-keyword">int</span>[] copy = b1.clone(); <span class="hljs-comment">// int[3] { 7, 3, 5 }</span>
numbers = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] { <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">19</span>, <span class="hljs-number">25</span> };
Arrays.copyOf(numbers, <span class="hljs-number">3</span>); <span class="hljs-comment">// int[3] { 5, 2, 1 }</span>
Arrays.copyOfRange(numbers, <span class="hljs-number">3</span>, <span class="hljs-number">3</span> + <span class="hljs-number">2</span>); <span class="hljs-comment">// int[2] { 10, 19 }</span>
</div></code></pre>
<h1 id="verzweigen-mit-der-if-anweisung">Verzweigen mit der if-Anweisung</h1>
<p>Hinweis: Die Bedingungen müssen boolesche Ausdrücke sein, d.h. die Berechnungen müssen entweder <code>true</code> oder <code>false</code> ergeben. Numerische Werte sind nicht erlaubt.</p>
<p>Die Verzweigungen <code>else if</code> und <code>else</code> sind immer optional.</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{
    <span class="hljs-keyword">if</span> (args.length &gt;= <span class="hljs-number">3</span>) {
        System.out.printf(
            <span class="hljs-string">"Name mit Anrede: %s %s %s\n"</span>, 
            args[<span class="hljs-number">0</span>], args[<span class="hljs-number">1</span>], args[<span class="hljs-number">2</span>]);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args.length &gt;= <span class="hljs-number">2</span>) {
        System.out.printf(
            <span class="hljs-string">"Name: %s %s\n"</span>, args[<span class="hljs-number">0</span>], args[<span class="hljs-number">1</span>]);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (args.length &gt;= <span class="hljs-number">1</span>) {
        System.out.printf(<span class="hljs-string">"Vorname: %s\n"</span>, args[<span class="hljs-number">0</span>]);
    } <span class="hljs-keyword">else</span> {
        System.out.println(
            <span class="hljs-string">"Rufen Sie das Program wie folgt auf:"</span> 
            + <span class="hljs-string">"[Anrede] Vorname Nachname"</span>);
    }
}
</div></code></pre>
<h1 id="operatoren">Operatoren</h1>
<p>Jeder Operator hat eine vordefinierte Priorität und ggf. eine Assoziativität. Die Assoziativität legt fest, ob zwei nebeneinanderstehende Operatoren gleicher Priorität von links oder rechts ausgewertet werden. Beispiel:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> age = <span class="hljs-number">17</span>;
<span class="hljs-keyword">boolean</span> isAdult = age &gt;= <span class="hljs-number">18</span>;
<span class="hljs-comment">// Zwei Operatoren: &gt;= und =</span>
<span class="hljs-comment">// Operatoren nach Priorität: &gt;=, =</span>
<span class="hljs-comment">// (boolean isAdult = (age &gt;= 18))</span>

<span class="hljs-comment">// 4 Operatoren: =, +, *, -</span>
<span class="hljs-comment">// Operatoren nach Priorität : *, +/-, =</span>
<span class="hljs-keyword">double</span> result = <span class="hljs-number">8</span> + <span class="hljs-number">3</span> * <span class="hljs-number">7</span> - <span class="hljs-number">1</span>
<span class="hljs-comment">// Auswertung durch Compiler:</span>
<span class="hljs-comment">// (double result = ((8 + (3 * 7)) - 1))</span>

<span class="hljs-comment">// 3 Operatoren: =, =, +</span>
<span class="hljs-comment">// Operatoren nach Priorität: +, =</span>
<span class="hljs-comment">// Assoziativität von = ist rechts.</span>
<span class="hljs-keyword">int</span> x;
<span class="hljs-keyword">int</span> y;
x = y = <span class="hljs-number">3</span> + <span class="hljs-number">1</span>
<span class="hljs-comment">// Auswertung durch Compiler:</span>
<span class="hljs-comment">// (x = (y = (3 + 1)))</span>
</div></code></pre>
<table>
<thead>
<tr>
<th>Operator</th>
<th>Bedeutung</th>
<th>Ergebnisdatentyp</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>Vergleicht Werte miteinander; Prüft auf Identität</td>
<td>Boolean</td>
</tr>
<tr>
<td>!=</td>
<td>Testet auf Ungleichheit bzw. auf unterschiedl. Identität</td>
<td>Boolean</td>
</tr>
<tr>
<td>&lt;</td>
<td>Kleiner als</td>
<td>Boolean</td>
</tr>
<tr>
<td>&gt;</td>
<td>Größer als</td>
<td>Boolean</td>
</tr>
<tr>
<td>&lt;=</td>
<td>Kleiner gleich als</td>
<td>Boolean</td>
</tr>
<tr>
<td>&gt;=</td>
<td>Größer gleich als</td>
<td>Boolean</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>Logische UND-Verknüpfung</td>
<td>Boolean</td>
</tr>
<tr>
<td>||</td>
<td>Logische ODER-Verknüpfung</td>
<td>Boolean</td>
</tr>
<tr>
<td>!</td>
<td>Logische Negation</td>
<td>Boolean</td>
</tr>
<tr>
<td>+</td>
<td>Addition oder String-Konkatenation</td>
<td>Numerisch oder String</td>
</tr>
<tr>
<td>-</td>
<td>Subtraktion</td>
<td>Numerisch</td>
</tr>
<tr>
<td>*</td>
<td>Multiplikation</td>
<td>Numerisch</td>
</tr>
<tr>
<td>/</td>
<td>Division (Integerdivision / Gleitkommadivision)</td>
<td>Numerisch</td>
</tr>
<tr>
<td>%</td>
<td>Modulo (Division mit Rest)</td>
<td>Numerisch</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>Bitshift nach rechts</td>
<td>Numerisch</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>Bitshift nach links</td>
<td>Numerisch</td>
</tr>
<tr>
<td>&amp;</td>
<td>Bitweises UND</td>
<td>Numerisch</td>
</tr>
<tr>
<td>|</td>
<td>Bitweises ODER</td>
<td>Numerisch</td>
</tr>
<tr>
<td>^</td>
<td>Bitweises ENTWEDER-ODER (XOR)</td>
<td>Numerisch</td>
</tr>
<tr>
<td>()</td>
<td>Call-Operator (Methoden aufrufen)</td>
<td>variabel</td>
</tr>
<tr>
<td>[]</td>
<td>Index-Operator (Elementzugriff bei Arrays)</td>
<td>variabel</td>
</tr>
<tr>
<td>.</td>
<td>Member-Access-Operator (Zugriff auf Felder, Methoden)</td>
<td>variabel</td>
</tr>
<tr>
<td>=</td>
<td>Zuweisungsoperator</td>
<td>variabel</td>
</tr>
<tr>
<td>++</td>
<td>Inkrement-Operator (Addieren von 1)</td>
<td>numerisch</td>
</tr>
<tr>
<td>--</td>
<td>Dekrement-Operator (Subtrahieren von 1)</td>
<td>numerisch</td>
</tr>
</tbody>
</table>
<h1 id="wiederholungen-mit-der-while-schleife">Wiederholungen mit der while-Schleife</h1>
<p>Hinweis: Die Anweisung <code>break</code> innerhalb der while-Schleife beendet die Schleife vorzeitig. Die Anweisung <code>continue</code> hingegen, springt direkt zum Kopf der Schleife, damit die Bedingung neu geprüft wird.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">while</span> (index &lt; args.length) {
    System.out.printf(<span class="hljs-string">"Argument %d: %s\n"</span>, index + <span class="hljs-number">1</span>, args[index]);
    index++;
}
</div></code></pre>
<h1 id="wiederholungen-mit-der-do-while-schleife">Wiederholungen mit der do-while-Schleife</h1>
<p>Diese Schleife ist fußgesteuert. Sie wird mindestens einmal ausgeführt. Die <code>break</code> Anweisung verlässt die Schleife vorzeitig. Die <code>continue</code> Anweisung springt direkt zum &quot;Fuß&quot; der Schleife, also zum Bedingungsausdruck.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">do</span> {
    System.out.printf(<span class="hljs-string">"Argument %d: %s\n"</span>, index + <span class="hljs-number">1</span>, args[index]);
    index++;
} <span class="hljs-keyword">while</span> (index &lt; args.length); <span class="hljs-comment">// &lt;- Semikolon!</span>
</div></code></pre>
<h1 id="wiederholungen-mit-der-for-schleife">Wiederholungen mit der for-Schleife</h1>
<p>Die for-Schleife besteht aus drei Bereichen: Initialisierungsbereich, Bedingungsbereich und &quot;Iterationsbereich&quot;.</p>
<p>Der Initialisierungsbereich wird einmal bei Betreten der Schleife ausgeführt. Der Bedingungsbereich wird <em>vor</em> jedem Schleifendurchlauf geprüft. Der Iterationsbereich wird <em>nach</em> jedem Schleifendurchlauf ausgeführt.</p>
<p>Die Anweisung <code>break</code> verlässt die Schleife vorzeitig, ohne dass der Iterationsbereich noch einmal ausgeführt wird. Die Anweisung <code>continue</code> springt direkt zum Iterationsbereich und danach zum Bedingungsbereich.</p>
<p>Hinweis: Lässt man den Bedingungsbereich leer, ist das gleichbedeutend mit <code>true</code>. Die Schleife wird also unendlich oft ausgeführt - eine sogenannte <em>Endlosschleife</em>.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; args.length; i++) {
    System.out.printf(<span class="hljs-string">"Argument %d: %s\n"</span>, i + <span class="hljs-number">1</span>, args[i]);
}

System.out.println(<span class="hljs-string">"\n\n"</span>); <span class="hljs-comment">// Leerzeilen einfügen.</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b = <span class="hljs-number">5</span> ; b &gt;= <span class="hljs-number">0</span> ; a++, b--) {
    System.out.printf(<span class="hljs-string">"a = %d und b = %d\n"</span>, a, b);
}
</div></code></pre>
<h1 id="wiederholen-mit-der-foreach-schleife">Wiederholen mit der foreach-Schleife</h1>
<p>Die foreach-Schleife vereinfacht die Verarbeitung von sequenziellen Datenmengen. Für jedes Element der Datensequenz wird der Schleifenrumpf ausgeführt. Um das Datenelement anzusprechen, das gerade abgearbeitet wird, muss man eine Laufvariable definieren.</p>
<p>Hinweis: Die foreach-Schleife funktioniert mit allen Datenobjekten, deren Datentyp die Schnittstelle <code>Iterable</code> implementiert.</p>
<p>Allgemeine Syntax:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (Datentyp element : datenmenge) {
    <span class="hljs-comment">// tue etwas mit element</span>
}
</div></code></pre>
<p>Hier ein paar konkrete Beispiele:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> (String argument : args) {
    System.out.printf(<span class="hljs-string">"Argument: %s\n"</span>, argument);
}

<span class="hljs-keyword">int</span>[] primes = { <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span> };
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> prime : primes) {
    System.out.println(prime);
}

<span class="hljs-comment">// Klasse String ist kein Iterable. Deshalb muss ein String</span>
<span class="hljs-comment">// vorher in ein Array konvertiert werden.</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : <span class="hljs-string">"Alice"</span>.toCharArray()) {
    System.out.printf(<span class="hljs-string">"%c "</span>, c);
}

<span class="hljs-comment">// Die Laufvariable kann nicht dazu benutzt werden, Elemente</span>
<span class="hljs-comment">// im Array zu überschreiben! Die Laufvariable ist lediglich</span>
<span class="hljs-comment">// eine Kopie des Elements.</span>
<span class="hljs-keyword">int</span>[] numbers = { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> };
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n : numbers) {
    n = n * <span class="hljs-number">2</span>; <span class="hljs-comment">// Kein Effekt auf numbers!</span>
}
</div></code></pre>
<h1 id="fallunterscheidungen-mit-der-switch-anweisungexpression">Fallunterscheidungen mit der switch-Anweisung/Expression</h1>
<p>Mittlerweile unterstützt die <code>switch</code> Anweisung beliebige Datentypen. Früher war man auf <code>int</code>, <code>char</code>, <code>String</code> beschränkt. Switch Statements unterstützen neuerdings auch sogenannte Patterns. Das ist ein erweitertes Feature, das wir erst später behandeln.</p>
<p>Hinweis: Verwendet man Zeichenketten (<code>String</code>) wird der Vergleich mittels <code>equals</code> vorgenommen. Die Groß und Kleinschreibung wird dadurch also berücksichtigt.</p>
<p>Besonders hilfreich bei der modernen switch-Variante ist das automatische Einfügen von <code>break</code>. Diese Funktionalität wird aber nur dann bereitgestellt, wenn wir nach dem Schlüsselwort <code>case</code> einen Pfeil <code>-&gt;</code> verwenden, statt eines Doppelpunktes <code>:</code>.</p>
<p>Hinweis: Fall-Throughs sind in Java möglich, wenn man das <code>break</code> in einem <code>case</code> weglässt.</p>
<p>Allgemeine Syntax:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Alte Variante</span>
<span class="hljs-keyword">switch</span> (ausdruck) {
    <span class="hljs-keyword">case</span> konstante1:
        anweisungen;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> konstante2:
        anweisungen;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
        anweisungen;
        <span class="hljs-keyword">break</span>;
}

<span class="hljs-comment">// Moderne Variante</span>
<span class="hljs-keyword">switch</span> (ausdruck) {
    <span class="hljs-comment">// Wird {} verwendet, entfällt das Semikolon. Es können</span>
    <span class="hljs-comment">// im {} Block mehrere Anweisungen ausgeführt werden.</span>
    <span class="hljs-keyword">case</span> konstante1, konstante2 -&gt; { anweisungen }
    <span class="hljs-comment">// Eine Anweisung ohne {} Block benötigt ein Semikolon.</span>
    <span class="hljs-keyword">case</span> konstante3 -&gt; anweisung;
    <span class="hljs-keyword">default</span> -&gt; anweisung;
}

<span class="hljs-comment">// In Form einer Expression:</span>
<span class="hljs-keyword">switch</span> (ausdruck) {
    <span class="hljs-comment">// Schlüsselwort yield dient zur Rückgabe eines Wertes</span>
    <span class="hljs-comment">// in einem {} Block.</span>
    <span class="hljs-keyword">case</span> konstante1, konstante2 -&gt; { anweisungen; yield wert; }
    <span class="hljs-comment">// Angabe von yield hier nicht notwendig, da kein {} Block.</span>
    <span class="hljs-keyword">case</span> konstante3 -&gt; wert;
    <span class="hljs-keyword">default</span> -&gt; wert;
}
</div></code></pre>
<h1 id="fallunterscheidung-mit-dem-conditional-operator">Fallunterscheidung mit dem Conditional Operator ?:</h1>
<p>Der Conditional-Operator ist eine &quot;kompakte Form&quot; für eine if-else-Anweisung. Im Unterschied zu <code>if</code> kann der Operator jedoch an allen Stellen verwendet werden, wo ein Berechnungsausdruck erwartet wird.</p>
<p>Der Operator besteht aus den beiden Symbolen <code>?</code> und <code>:</code>. Es sind drei Ausdrücke <code>A</code>, <code>B</code> und <code>C</code> anzugeben. Beispiel:</p>
<pre class="hljs"><code><div>A ? B : C

<span class="hljs-comment">// Ungefähre Analogie zur if-else-Anweisung</span>
<span class="hljs-keyword">if</span> (A == <span class="hljs-keyword">true</span>) {
    B ist das Ergebnis des Operators
} <span class="hljs-keyword">else</span> {
    C ist das Ergebnis des Operators
}
</div></code></pre>
<p>Der Operator arbeitet wie folgt: Es wird zuerst geprüft, ob <code>A</code> den Wert <code>true</code> liefert. Falls dem so ist, wird <code>B</code> ausgewertet und dessen Wert als Ergebnis zurückgegeben. Falls jedoch <code>A</code> false ist, wird <code>C</code> ausgewertet und das Ergebnis von <code>C</code> als Gesamtergebnis zurückgegeben.</p>
<p>Es ist zu beachten, dass die Ausdrücke <code>B</code> und <code>C</code> Werte gleichen Datentyps liefern.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> a = <span class="hljs-number">3</span>;
<span class="hljs-keyword">int</span> b = <span class="hljs-number">7</span>;
<span class="hljs-keyword">int</span> max;

<span class="hljs-comment">// Maximum mit if-Verzweigung ermitteln.</span>
<span class="hljs-keyword">if</span> (a &gt; b) {
    max = a;
} <span class="hljs-keyword">else</span> {
    max = b;
}

<span class="hljs-comment">// Mit dem Conditional Operator geht es kompakter.</span>
max = a &gt; b ? a : b;

<span class="hljs-comment">// Folgende Anweisung kompiliert nicht, da </span>
<span class="hljs-comment">// B und C den Datentyp void haben, also keinen Wert liefern.</span>
a &gt; b ? System.out.println(<span class="hljs-string">"a ist Maximum"</span>) : System.out.println(<span class="hljs-string">"b ist Maximum"</span>);
</div></code></pre>
<h1 id="fehler-behandeln-mit-try-catch-finally">Fehler behandeln mit try-catch-finally</h1>
<p>In Java werden Fehler durch sogenannte Exception-Objekte abgebildet. Das sind herkömmliche Instanzen der Klasse <code>Exception</code>. Es gibt zwei Arten von Exceptions: <em>checked</em> und <em>unchecked</em>. Eine checked Exception muss vom Entwickler abgefangen werden, eine unchecked Exception jedoch nicht.</p>
<p>Exceptions, die von der Klasse <code>RuntimeException</code> erben, sind <em>unchecked</em>. Andere Exceptions sind <em>checked</em>.</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Beim Parsing eines Strings nach int, kann es z.B.</span>
<span class="hljs-comment">// zur Exception "NumberFormatException" kommen.</span>
<span class="hljs-comment">// Dies ist im folgenden Beispiel der Fall.</span>
<span class="hljs-keyword">int</span> number = Integer.parseInt(<span class="hljs-string">"i am not a number"</span>);
</div></code></pre>
<p>Im Normalfall führt eine Exception zum Programmabbruch. Um das zu vermeiden, muss die Exception durch den Entwickler abgefangen und behandelt werden. Das geht mit der sogenannten <code>try-catch</code> Anweisung. Beispiel:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">try</span> {
    <span class="hljs-comment">// Anweisungen, die Exceptions</span>
    <span class="hljs-comment">// auslösen könnten.</span>
} <span class="hljs-keyword">catch</span> (ExceptionTyp e) {
    <span class="hljs-comment">// Hier kann die Fehlerbehandlung erfolgen.</span>
    <span class="hljs-comment">// Mit der Variablen e können Informationen</span>
    <span class="hljs-comment">// der Exception abgerufen werden.</span>

    <span class="hljs-comment">// Jede Exception kann einen Stack-Trace ausgeben.</span>
    <span class="hljs-comment">// Das ist der Aufrufstapel / die Aufrufhierarchie, der/die</span>
    <span class="hljs-comment">// zur Exception geführt hat.</span>
    e.printStackTrace();
    <span class="hljs-comment">// Jede Exception enthält mindestens einen Fehlertext,</span>
    <span class="hljs-comment">// der mit getMessage() abrufbar ist.</span>
    e.getMessage();
    <span class="hljs-comment">// Exceptions können trotz Fehlerbehandlung an den Aufrufer</span>
    <span class="hljs-comment">// per throw weitergereicht werden.</span>
    <span class="hljs-keyword">throw</span> e;
    <span class="hljs-comment">// Eine neue Exception auslösen und die ursprüngliche</span>
    <span class="hljs-comment">// Exception als Zusatzinfo mitgeben.</span>
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MyOwnException(<span class="hljs-string">"message"</span>, e);
} <span class="hljs-keyword">finally</span> {
   <span class="hljs-comment">// Hier stehen Anweisungen, die immer auszuführen sind,</span>
   <span class="hljs-comment">// egal ob die Anweisungen im try-Block eine</span>
   <span class="hljs-comment">// Exception ausgelöst haben oder nicht. </span>

   <span class="hljs-comment">// Typischerweise werden hier die Ressourcen freigegeben,</span>
   <span class="hljs-comment">// die im try-Block reserviert wurden.</span>

   <span class="hljs-comment">// Selbst wenn im catch-Block ein return ausgeführt wird,</span>
   <span class="hljs-comment">// werden die hier stehenden Anweisungen vorher noch</span>
   <span class="hljs-comment">// ausgeführt.</span>
}
</div></code></pre>
<p>Hinweis: Es dürfen mehrere <code>catch</code> Blöcke auf einen <code>try</code> Block folgen. Jeder <code>catch</code> Block kann eine oder mehrere Exceptions abfangen. Es muss darauf geachtet werden, dass spezifische Exceptions vor allgemeineren Exceptions per <code>catch</code> abzufangen sind.</p>
<p>Wenn eine Exception ausgelöst, aber nicht per <code>try-catch</code> behandelt wird, dann bricht die Java Runtime Environment die aktuelle Methode ab und reicht das Exception Objekt an den Aufrufer der Methode. Falls auch der Aufrufer die Exception nicht abfängt, wird die Exception abermals an den Aufrufer des Aufrufers weitergereicht usw. Sofern die Exception an die <code>main</code> Methode weitergereicht und dort nicht behandelt wird, bricht das Programm abrupt ab.</p>
<h1 id="den-compiler-den-variablendatentyp-ermitteln-lassen">Den Compiler den Variablendatentyp ermitteln lassen</h1>
<p>In wenigen Situationen ist es hilfreich, den Compiler den Datentyp einer Variablen selbst ermitteln zu lassen. Das ist zum Beispiel bei der Objektkonstruktion der Fall. Dort muss man häufig den Datentyp zweimal angeben: nach dem <code>new</code> Operator und vor der zu erstellenden Variable. Um diese Redundanz zu vermeiden, bietet Java das Schlüsselwort <code>var</code> an. Beispiel:</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Ohne Verwendung von var:</span>
HashMap&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Integer, String&gt;();

<span class="hljs-comment">// Mit Verwendung von var.</span>
<span class="hljs-comment">// Compiler setzt den Datentyp für Variable map</span>
<span class="hljs-comment">// automatisch auf HashMap&lt;Integer, String&gt;.</span>
<span class="hljs-keyword">var</span> map = <span class="hljs-keyword">new</span> HashMap&lt;Integer, String&gt;();
</div></code></pre>
<p>Hinweis: Javas <code>var</code> hat nichts mit dem <code>var</code> der Sprache JavaScript zu tun. Mit <code>var</code> erzeugen wir in Java eine Variable mit festgelegtem Datentyp, der sich nicht später ändern kann.</p>
<h1 id="die-standard-streams-eines-programms">Die Standard Streams eines Programms</h1>
<p>Für jedes Programm, das wir ausführen, erstellt das Betriebssytem eine Datenstruktur namens <em>Prozess</em>. Diese enthält sämtliche Informationen über das laufende Programm einschließlich verwendeter Resourcen und Zugriffsrechte.</p>
<p>Standardmäßig besitzt jeder Prozess einen Input Stream und zwei Output Streams. Wenn man ein Kommandozeilenprogramm startet, ist der Input Stream für gewöhnlich mit dem Terminal verbunden. Dasselbe gilt für die beiden Output Streams (Normal und Error).</p>
<p>In Java können wir diese Streams mit <code>System.in</code> (Input Stream), <code>System.out</code> (Output Stream) und <code>System.err</code> (Error Output Stream) ansprechen.</p>
<p>Im Terminal lassen sich die Quellen und Senken der Streams konfigurieren. Somit können auch Daten aus Dateien gelesen und Daten in Dateien geschrieben werden. Beispiel:</p>
<pre class="hljs"><code><div><span class="hljs-comment"># Inhalt von Datei numbers.txt mit dem</span>
<span class="hljs-comment"># Input Stream von Adder verknüpfen.</span>
cat .\numbers.txt | java .\Adder.java

<span class="hljs-comment"># Daten des Output Streams von Adder in Datei</span>
<span class="hljs-comment"># output.txt schreiben.</span>
java Adder.java &gt; output.txt
</div></code></pre>
<p><img src="../diagrams/standard-streams-of-a-process.svg" alt=""></p>
<h1 id="daten-einlesen-mit-der-klasse-scanner">Daten einlesen mit der Klasse Scanner</h1>
<p>Ein Scanner ist ein Objekt, mit dem wir Daten aus verschiedenen Datenquellen lesen können. Mögliche Quellen sind zum Beispiel Dateien, Zeichenketten, Pipes (FIFO), Network Sockets und natürlich Terminals.</p>
<p>Der Scanner liest seine Daten wie von einem &quot;Transportband&quot;. Im Normalfall liest der Scanner immer bis zum nächsten Whitespace Zeichen - dem Delimiter.</p>
<p>Standardmäßig blockiert ein Scanner das Programm, wenn Daten einzulesen sind, aber das &quot;Transportband&quot; leer ist.</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Scanner liest Daten aus dem Input Stream.</span>
<span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> Scanner(System.in);
<span class="hljs-comment">// Blockiert, falls keine Daten im Stream vorhanden.</span>
<span class="hljs-keyword">int</span> number = s.nextInt();
<span class="hljs-keyword">int</span> anotherNumber = s.nextInt(); 

System.out.printf(<span class="hljs-string">"Eingelesene Zahl ist %d\n"</span>, number);
System.out.printf(<span class="hljs-string">"Zweite eingelesene Zahl ist %d\n"</span>, anotherNumber);
<span class="hljs-comment">// Gibt es noch weitere Daten im Input Stream?</span>
<span class="hljs-keyword">if</span> (s.hasNext()) {
    System.out.printf(<span class="hljs-string">"Weitere Daten: %s\n"</span>, s.next());
}
</div></code></pre>
<p>Wenn man den Nutzer auf dem Terminal dazu auffordert, etwas einzugeben, dann kann es unter Umständen passieren, dass er mehrere <em>Tokens</em> (durch Delimiter getrennte Zeichenfolgen) eintippt. Die <code>next</code> Methoden des Scanners würden dann nicht an jeder Stelle blockieren, sondern automatisch das nächste Token einlesen. Um das zu vermeiden, kann man zum Beispiel <code>nextLine</code> mit explizitem Parsing verwenden. Beispiel:</p>
<pre class="hljs"><code><div>String input;
System.out.print(<span class="hljs-string">"Gib eine Zahl ein: "</span>);
input = scanner.nextLine();
<span class="hljs-keyword">int</span> firstNumber = Integer.parseInt(input);
System.out.print(<span class="hljs-string">"Gib eine zweite Zahl ein: "</span>);
<span class="hljs-comment">// Gesamte Zeile einlesen</span>
input = scanner.nextLine();
<span class="hljs-comment">// Manuell in int parsen.</span>
<span class="hljs-keyword">int</span> secondNumber = Integer.parseInt(input);
<span class="hljs-keyword">int</span> sum = firstNumber + secondNumber;
System.out.printf(<span class="hljs-string">"%d + %d = %d!\n"</span>, firstNumber, secondNumber, sum);
</div></code></pre>
<p><strong>Achtung:</strong> Der Scanner berücksichtigt die aktuell eingestellten regionalen Einstellungen (<em>Locale</em>). Die herkömmlichen <code>parse</code> Methoden (wie z.B. <code>Double.parseDouble</code>) berücksichtigen keine regionalen Einstellungen! Die Locale kann für den Scanner konfiguriert werden:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> scanner = <span class="hljs-keyword">new</span> Scanner(System.in);
scanner.useLocale(Locale.GERMANY);
<span class="hljs-comment">// Scanner berücksichtigt die Locale. Hier wird</span>
<span class="hljs-comment">// ein Komma als Dezimaltrenner erwartet, da GERMANY</span>
<span class="hljs-comment">// eingestellt ist.</span>
<span class="hljs-keyword">double</span> value = scanner.nextDouble();
<span class="hljs-comment">// parseDouble berücksichtigt keine Locale. Hier ist der</span>
<span class="hljs-comment">// Dezimaltrenner immer ein Punkt (.)</span>
value = Double.parseDouble(<span class="hljs-string">"123.456"</span>); 
<span class="hljs-comment">// printf verwendet die per Default eingestellte Locale.</span>
<span class="hljs-comment">// In Deutschland würde die Gleitkommazahl mit Dezimaltrenner ,</span>
<span class="hljs-comment">// ausgegeben werden. Um die Locale explizit festzulegen,</span>
<span class="hljs-comment">// kann man als erstes Argument die Locale vorgeben. Hier US.</span>
System.out.printf(Locale.US, <span class="hljs-string">"%f"</span>, <span class="hljs-number">2.56</span>); <span class="hljs-comment">// 2.56</span>
System.out.printf(Locale.GERMANY, <span class="hljs-string">"%f"</span>, <span class="hljs-number">2.56</span>); <span class="hljs-comment">// 2,56</span>
</div></code></pre>
<p>Funktionsweise des Scanners als Diagramm:</p>
<p><img src="../diagrams/how-a-scanner-works.svg" alt=""></p>
<h1 id="dateien-einlesen">Dateien einlesen</h1>
<p>In den Packages <code>java.io</code>, <code>java.nio.file</code> und <code>java.nio</code> befinden sich zahlreiche Klassen, um Dateien und Verzeichnisse zu verwalten.</p>
<p>Um den Inhalt einer Textdatei einzulesen, kann man die Klasse <code>Files</code> verwenden in Kombination mit der Klasse <code>Path</code> und <code>StandardCharsets</code>. Beispiel:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.nio.file.Files;
<span class="hljs-keyword">import</span> java.nio.file.Path;
<span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;

<span class="hljs-comment">// Erstelle den relativen Pfad ".\data\contacts.txt"</span>
<span class="hljs-comment">// Hinweis: Es wird nicht geprüft, ob dieser Pfad</span>
<span class="hljs-comment">// tatsächlich im Dateisystem existiert!</span>
Path pathToFile = Path.of(<span class="hljs-string">"data"</span>, <span class="hljs-string">"contacts.txt"</span>);
<span class="hljs-comment">// Lies gesamten Inhalt der Datei und gehe davon aus,</span>
<span class="hljs-comment">// dass die Zeichenkodierung UTF-8 für den Inhalt</span>
<span class="hljs-comment">// verwendet wurde.</span>
String fileContent = Files.readString(pathToFile, StandardCharsets.UTF_8);
</div></code></pre>
<p>Methoden, die auf Dateien zugreifen, können in den meisten Fällen <code>IOExceptions</code> auslösen. Solche Exceptions sind <em>checked</em> und müssen deshalb abgefangen werden. Beispiel:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">import</span> java.nio.file.Files;
<span class="hljs-keyword">import</span> java.nio.file.Path;
<span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;
<span class="hljs-keyword">import</span> java.io.IOException;
<span class="hljs-keyword">import</span> java.nio.file.AccessDeniedException;
<span class="hljs-keyword">import</span> java.nio.file.NoSuchFileException;

<span class="hljs-keyword">try</span> {
    Path pathToFile = Path.of(<span class="hljs-string">"data"</span>, <span class="hljs-string">"contacts.txt"</span>);
    String logContent = Files.readString(pathToFile, StandardCharsets.UTF_8);
} <span class="hljs-keyword">catch</span> (AccessDeniedException e) {
    System.err.printf(<span class="hljs-string">"Kein Lesezugriff.\n"</span>);
} <span class="hljs-keyword">catch</span> (NoSuchFileException e) {
    System.err.printf(<span class="hljs-string">"Datei existiert nicht.\n"</span>);
} <span class="hljs-keyword">catch</span> (IOException ioe) {
    System.err.printf(<span class="hljs-string">"Irgendein anderer Input/Output Fehler\n"</span>);
}
</div></code></pre>
<h1 id="unterschied-zwischen-referenzdatentypen-und-primitiven-datentypen">Unterschied zwischen Referenzdatentypen und primitiven Datentypen</h1>
<p>Wenn wir einen Wert primitiven Datentyps in einer Variablen speichern, dann enthält diese Variable den vollständigen Wert. Kopiert man nun diese Variable in eine andere Variable, so wird der Wert vollständig kopiert.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span> a = <span class="hljs-number">123</span>;
<span class="hljs-comment">// Der Wert 123 wird nach b kopiert.</span>
<span class="hljs-keyword">int</span> b = a;
<span class="hljs-comment">// b ist vollständige Kopie von a.</span>
b++;
<span class="hljs-comment">// a ist weiterhin 123</span>
<span class="hljs-comment">// b ist nun 124.</span>
</div></code></pre>
<p>Erstellen wir eine Variable mit einem Referenzdatentyp, dann speichert diese Variable nicht ein Datenobjekt, sondern lediglich einen Verweis auf ein Datenobjekt. Man kann sich eine Referenz wie eine Speicheradresse oder ID vorstellen. Kopiert man nun diese sogenannte Referenzvariable in eine andere, dann wird also nicht das referenzierte Objekt kopiert, sondern lediglich die Referenz. Dadurch verweisen nun Originalvariable und Kopievariable auf dasselbe Objekt im Speicher.</p>
<pre class="hljs"><code><div><span class="hljs-comment">// Variable name enthält _nicht_ das StringBuilder-Objekt,</span>
<span class="hljs-comment">// sondern nur einen Verweis auf dieses Objekt.</span>
<span class="hljs-keyword">var</span> name = <span class="hljs-keyword">new</span> StringBuilder(<span class="hljs-string">"Bob"</span>);
<span class="hljs-comment">// Indem wir name nach copy kopieren, kopieren wir lediglich</span>
<span class="hljs-comment">// die Referenz. copy und name verweisen nun auf dasselbe</span>
<span class="hljs-comment">// StringBuilder-Objekt.</span>
StringBuilder copy = name;

System.out.println(name); <span class="hljs-comment">// Bob</span>
System.out.println(copy); <span class="hljs-comment">// Bob</span>
name.append(<span class="hljs-string">" Ross"</span>);
System.out.println(name); <span class="hljs-comment">// Bob Ross</span>
System.out.println(copy); <span class="hljs-comment">// Bob Ross</span>
</div></code></pre>
<p>Rufen wir eine Methode auf, dann werden die Argumente in die zugehörigen Parameter kopiert. Im Falle von primitiven Werten, entsteht dabei eine vollständige Kopie. Falls Referenzen kopiert werden, kann die aufgerufene Methode über diese Referenz auf das Datenobjekt direkt zugreifen. Sie erhält also keine Kopie eines Datenobjekts.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span>[] primes = { <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span> };
<span class="hljs-comment">// Variable primes wird in Parameter numbers der Methode modify</span>
<span class="hljs-comment">// kopiert. Dadurch erlangt modify direkten Zugriff auf das</span>
<span class="hljs-comment">// Array primes.</span>
modify(primes);
<span class="hljs-comment">// Gibt aus: [111, 3, 5, 7, 11]</span>
System.out.println(Arrays.toString(primes));

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] numbers)</span> </span>{
    numbers[<span class="hljs-number">0</span>] = <span class="hljs-number">111</span>;
}
</div></code></pre>
<p>Die Übergabe von Argumenten an Methoden geschieht in Java stets <em>by value</em>. Der Wert wird also in den Parameter kopiert.</p>
<p>Fälschlicherweise wird oft behauptet, Java unterstütze <em>Pass by Reference</em>. Pass by Reference hieße, dass ein Parameter Alias / Repräsentant einer anderen Variable sein darf.</p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span>[] primes = { <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span> };
modify(primes);

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] numbers)</span> </span>{
    <span class="hljs-comment">// Da Argumente by Value übergeben werden,</span>
    <span class="hljs-comment">// ist numbers lediglich Kopie von primes.</span>
    <span class="hljs-comment">// Weisen wir numbers ein neues Array Objekt</span>
    <span class="hljs-comment">// zu, hat dies keine Auswirkung auf primes.</span>
    numbers = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] { <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">19</span>, <span class="hljs-number">23</span> };
}

<span class="hljs-comment">// Gäbe es eine Art "Pass By Reference" in Java</span>
<span class="hljs-comment">// könnte man primes direkt mittels numbers "umlenken"</span>
<span class="hljs-comment">// auf ein anderes Array-Objekt. Pseudo Code:</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(ref <span class="hljs-keyword">int</span>[] numbers)</span> </span>{
    <span class="hljs-comment">// hier würde indirekt stehen: primes = new int[] { 1, 2, 3}</span>
    numbers = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}
}
</div></code></pre>
<h1 id="primitive-werte-vergleichen-und-referenzen-vergleichen">Primitive Werte vergleichen und Referenzen vergleichen</h1>
<p>Wenn wir zwei Variablen mit dem <code>==</code> Operator vergleichen, prüfen wir, ob sich in beiden Variablen dasselbe Bitmuster befindet. Das hat folgende Sequenzen:</p>
<p>Wenn die zu vergleichenden Variablen primitiven Datentyp haben, so wird effektiv geprüft, ob beide Variablen gleiche Werte besitzen. Beispiel: Wenn <code>int a = 3</code> und <code>int b = 3</code> dann ist <code>a == b</code> wahr, da ja in beiden der Wert 3 steht.</p>
<p>Wenn die zu vergleichenden Variablen einen Referenzdatentyp haben, so wird effektiv geprüft, ob beide Variablen auf dasselbe Objekt im Speicher verweisen. Beispiel:</p>
<pre class="hljs"><code><div>String a = new String(&quot;abc&quot;);
String b = new String(&quot;abc&quot;);

a == b liefert false, da a und b auf unterschiedliche String-Objekte verweisen.
a.equals(b) liefert true, da a und b auf String-Objekte verweisen, die den gleichen Inhalt besitzen.

String a = &quot;max&quot;;
String b = a;

a == b liefert true, da nun a und b auf dasselbe String-Objekt verweisen.
a.equals(b) liefert true, da a und b auf String-Objekte verweisen, die denselben Inhalt besitzen.
</div></code></pre>
<p><img src="../diagrams/reference-variables-vs-primitive-variables.svg" alt=""></p>
<p>Hinweis: Wenn <code>a == b</code> gilt, dann sollte auch <code>a.equals(b)</code> den Wert <code>true</code> liefern. Umgekehrt kann jedoch aus <code>a.equals(b)</code> nicht geschlussfolgert werden, dass auch <code>a == b</code> gilt. Nur weil zwei Objekte <em>gleich</em> sind, heißt das nicht, dass sie auch <em>identisch</em> sind.</p>
<h1 id="arrays-kopieren">Arrays kopieren</h1>
<p>Kopieren wir einen Array, dessen Elemente primitiv sind (z.B. int, double), so ist die Kopie völlig isoliert vom Original.</p>
<p>Kopieren wir jedoch einen Array, dessen Elemente Referenzen sind (z.B. String, StringBuilder), so ist die Kopie nur teilweise vom Original isoliert. Die &quot;Zellen&quot; des Originals und der Kopie verweisen nämlich auf diesselben Datenobjekte im Speicher. Einerseits ist dadurch das Kopieren schnell erledigt, andererseits birgt das aber auch Gefahren, wenn man die referenzierten Objekte modifiziert.</p>
<p><img src="../diagrams/shallow-copy-of-array.svg" alt=""></p>
<p>Würde man eine vollständig isolierte Kopie erzeugen wollen, müsste man auch die von den Zellen referenzierten Datenobjekte kopieren. Das ist aber weder bei <code>clone</code> noch bei <code>Arrays.copyOf</code> der Fall.</p>
<h1 id="zweidimensionale-und-dreidimensionale-arrays">Zweidimensionale und dreidimensionale Arrays</h1>
<p>Java unterstützt nur eindimensionale Arrays. Möchte man mehrere Dimensionen abbilden, kann man Arrays ineinander schachteln. Ein zweidimensionaler Array ist letztlich nur ein eindimensionaler Array, dessen Elemente ebenfalls Arrays sind.</p>
<p><img src="../diagrams/2d-array-example.svg" alt=""></p>
<p><img src="../diagrams/2d-array-example-memory-layout.svg" alt=""></p>
<pre class="hljs"><code><div><span class="hljs-keyword">int</span>[][] table = {
    { <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> },
    { <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span> },
    { <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span> },
};
<span class="hljs-comment">// Datentyp von table ist int[3][].</span>
<span class="hljs-comment">// Datentyp von table[0] ist int[4].</span>
<span class="hljs-comment">// Datentyp von table[1] ist int[5].</span>
<span class="hljs-comment">// Datentyp von table[2] ist int[3].</span>
<span class="hljs-comment">// Datentyp von table[2][1] ist int.</span>
</div></code></pre>
<p><img src="../diagrams/3d-array-example-memory-layout.svg" alt=""></p>

</body>
</html>
